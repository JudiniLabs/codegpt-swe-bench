{
    "sympy/matrices/expressions/blockmatrix.py": [
        {
            "orig_text": "from sympy.matrices.expressions.matexpr import MatrixExpr, ZeroMatrix, Identity\n",
            "new_text": "from sympy.matrices.expressions.matexpr import MatrixExpr, ZeroMatrix, Identity, MatrixElement\n",
            "match_ratio": 1.0,
            "match_segment": "from sympy.matrices.expressions.matexpr import MatrixExpr, ZeroMatrix, Identity\n",
            "start_idx": 305,
            "num_matches": 1
        },
        {
            "orig_text": "    def _entry(self, i, j, **kwargs):\n        # Find row entry\n        for row_block, numrows in enumerate(self.rowblocksizes):\n            if (i < numrows) != False:\n                break\n            else:\n                i -= numrows\n        for col_block, numcols in enumerate(self.colblocksizes):\n            if (j < numcols) != False:\n                break\n            else:\n                j -= numcols\n        return self.blocks[row_block, col_block][i, j]\n",
            "new_text": "    def _entry(self, i, j, **kwargs):\n        from sympy.core.numbers import Integer\n        \n        # Try to determine which block contains the element\n        row_block = None\n        col_block = None\n        i_offset = i\n        j_offset = j\n        \n        # Find row block\n        cumulative_rows = 0\n        for idx, numrows in enumerate(self.rowblocksizes):\n            # Check if index is numeric\n            if isinstance(i, (int, Integer)):\n                if i < cumulative_rows + numrows:\n                    row_block = idx\n                    i_offset = i - cumulative_rows\n                    break\n                cumulative_rows += numrows\n            else:\n                # For symbolic indices, check if we can determine the block\n                # Check if i is definitely in this block\n                if (i - cumulative_rows).is_nonnegative and (i < cumulative_rows + numrows) == True:\n                    row_block = idx\n                    i_offset = i - cumulative_rows\n                    break\n                # Check if i is definitely past this block\n                elif (i >= cumulative_rows + numrows) == True:\n                    cumulative_rows += numrows\n                else:\n                    # Cannot determine - need to return unevaluated\n                    break\n        \n        # Find column block\n        cumulative_cols = 0\n        for idx, numcols in enumerate(self.colblocksizes):\n            # Check if index is numeric\n            if isinstance(j, (int, Integer)):\n                if j < cumulative_cols + numcols:\n                    col_block = idx\n                    j_offset = j - cumulative_cols\n                    break\n                cumulative_cols += numcols\n            else:\n                # For symbolic indices, check if we can determine the block\n                # Check if j is definitely in this block\n                if (j - cumulative_cols).is_nonnegative and (j < cumulative_cols + numcols) == True:\n                    col_block = idx\n                    j_offset = j - cumulative_cols\n                    break\n                # Check if j is definitely past this block\n                elif (j >= cumulative_cols + numcols) == True:\n                    cumulative_cols += numcols\n                else:\n                    # Cannot determine - need to return unevaluated\n                    break\n        \n        # If we could determine both blocks, return the element from that block\n        if row_block is not None and col_block is not None:\n            return self.blocks[row_block, col_block][i_offset, j_offset]\n        \n        # Otherwise, return an unevaluated MatrixElement\n        return MatrixElement(self, i, j)\n",
            "match_ratio": 1.0,
            "match_segment": "    def _entry(self, i, j, **kwargs):\n        # Find row entry\n        for row_block, numrows in enumerate(self.rowblocksizes):\n            if (i < numrows) != False:\n                break\n            else:\n                i -= numrows\n        for col_block, numcols in enumerate(self.colblocksizes):\n            if (j < numcols) != False:\n                break\n            else:\n                j -= numcols\n        return self.blocks[row_block, col_block][i, j]\n",
            "start_idx": 8426,
            "num_matches": 1
        }
    ]
}