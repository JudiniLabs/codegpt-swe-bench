{
    "django/db/models/sql/query.py": [
        {
            "orig_text": "from django.core.exceptions import (\n    EmptyResultSet, FieldDoesNotExist, FieldError,\n)\nfrom django.db import DEFAULT_DB_ALIAS, NotSupportedError, connections\nfrom django.db.models.aggregates import Count\n",
            "new_text": "from django.core.exceptions import (\n    EmptyResultSet, FieldDoesNotExist, FieldError,\n)\nfrom django.db import DEFAULT_DB_ALIAS, NotSupportedError, connections\nfrom django.db.models.aggregates import Count\n",
            "match_ratio": 1.0,
            "match_segment": "from django.core.exceptions import (\n    EmptyResultSet, FieldDoesNotExist, FieldError,\n)\nfrom django.db import DEFAULT_DB_ALIAS, NotSupportedError, connections\nfrom django.db.models.aggregates import Count\n",
            "start_idx": 606,
            "num_matches": 1
        },
        {
            "orig_text": "    def set_group_by(self, allow_aliases=True):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \"\"\"\n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                signature = inspect.signature(annotation.get_group_by_cols)\n                if 'alias' not in signature.parameters:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    if not allow_aliases:\n                        alias = None\n                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n",
            "new_text": "    def set_group_by(self, allow_aliases=True):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \"\"\"\n        group_by = list(self.select)\n        if self.annotation_select:\n            # Collect all column names from tables in alias_map to detect collisions\n            column_names = set()\n            if allow_aliases:\n                # Get the base model's fields\n                base_model = self.model\n                if base_model:\n                    for field in base_model._meta.get_fields():\n                        if hasattr(field, 'column'):\n                            column_names.add(field.column)\n                \n                # Get column names from joined tables\n                for alias, alias_info in self.alias_map.items():\n                    if hasattr(alias_info, 'join_field') and alias_info.join_field:\n                        # Get the related model\n                        join_field = alias_info.join_field\n                        if hasattr(join_field, 'related_model') and join_field.related_model:\n                            related_model = join_field.related_model\n                            for field in related_model._meta.get_fields():\n                                if hasattr(field, 'column'):\n                                    column_names.add(field.column)\n                        # Also check the source model of the join\n                        if hasattr(join_field, 'model') and join_field.model:\n                            for field in join_field.model._meta.get_fields():\n                                if hasattr(field, 'column'):\n                                    column_names.add(field.column)\n            \n            for alias, annotation in self.annotation_select.items():\n                signature = inspect.signature(annotation.get_group_by_cols)\n                if 'alias' not in signature.parameters:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    # Check for collision with column names in joined tables\n                    use_alias = alias\n                    if not allow_aliases or (alias in column_names):\n                        use_alias = None\n                    group_by_cols = annotation.get_group_by_cols(alias=use_alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n",
            "match_ratio": 1.0,
            "match_segment": "    def set_group_by(self, allow_aliases=True):\n        \"\"\"\n        Expand the GROUP BY clause required by the query.\n\n        This will usually be the set of all non-aggregate fields in the\n        return data. If the database backend supports grouping by the\n        primary key, and the query would be equivalent, the optimization\n        will be made automatically.\n        \"\"\"\n        group_by = list(self.select)\n        if self.annotation_select:\n            for alias, annotation in self.annotation_select.items():\n                signature = inspect.signature(annotation.get_group_by_cols)\n                if 'alias' not in signature.parameters:\n                    annotation_class = annotation.__class__\n                    msg = (\n                        '`alias=None` must be added to the signature of '\n                        '%s.%s.get_group_by_cols().'\n                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n                    warnings.warn(msg, category=RemovedInDjango40Warning)\n                    group_by_cols = annotation.get_group_by_cols()\n                else:\n                    if not allow_aliases:\n                        alias = None\n                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n                group_by.extend(group_by_cols)\n        self.group_by = tuple(group_by)\n",
            "start_idx": 86009,
            "num_matches": 1
        }
    ]
}