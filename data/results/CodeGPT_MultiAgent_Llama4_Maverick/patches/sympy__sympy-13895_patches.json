{
    "sympy/core/power.py": [
        {
            "orig_text": "def _eval_power(self, other):\n from sympy import Abs, arg, exp, floor, im, log, re, sign\n from sympy.core.function import _coeff_isneg\n b, e = self.as_base_exp()\n if b is S.NaN:\n return (b**e)**other # let __new__ handle it\n\n s = None\n if other.is_integer:\n s =1\n elif b.is_polar: # e.g. exp_polar, besselj, var('p', polar=True)...\n s =1\n elif e.is_real is not None:\n # helper functions ===========================\n def _half(e):\n \"\"\"Return True if the exponent has a literal2 as the\n denominator, else None.\"\"\"\n if getattr(e, 'q', None) ==2:\n return True\n n, d = e.as_numer_denom()\n if n.is_integer and d ==2:\n return True\n def _n2(e):\n \"\"\"Return ``e`` evaluated to a Number with2 significant\n digits, else None.\"\"\"\n try:\n rv = e.evalf(2, strict=True)\n if rv.is_Number:\n return rv\n except PrecisionExhausted:\n pass\n # ===================================================\n if e.is_real:\n # we need _half(other) with constant floor or\n # floor(S.Half - e*arg(b)/2/pi) ==0\n\n # handle -1 as special case\n if e == -1:\n # floor arg. is1/2 + arg(b)/2/pi\n if _half(other):\n if b.is_negative is True:\n return S.NegativeOne**other*Pow(-b, e*other)\n if b.is_real is False:\n return Pow(b.conjugate()/Abs(b)**2, other)\n elif e.is_even:\n if b.is_real:\n b = abs(b)\n if b.is_imaginary:\n b = abs(im(b))*S.ImaginaryUnit\n\n if (abs(e) <1) == True or e ==1:\n s =1 # floor =0\n elif b.is_nonnegative:\n s =1 # floor =0\n elif re(b).is_nonnegative and (abs(e) <2) == True:\n s =1 # floor =0\n elif fuzzy_not(im(b).is_zero) and abs(e) ==2:\n s =1 # floor =0\n elif _half(other):\n s = exp(2*S.Pi*S.ImaginaryUnit*other*floor(\n S.Half - e*arg(b)/(2*S.Pi)))\n if s.is_real and _n2(sign(s) - s) ==0:\n s = sign(s)\n else:\n s = None\n else:\n # e.is_real is False requires:\n # _half(other) with constant floor or\n # floor(S.Half - im(e*log(b))/2/pi) ==0\n try:\n s = exp(2*S.ImaginaryUnit*S.Pi*other*\n floor(S.Half - im(e*log(b))/2/S.Pi))\n # be careful to test that s is -1 or1 b/c sign(I) == I:\n # so check that s is real\n if s.is_real and _n2(sign(s) - s) ==0:\n s = sign(s)\n else:\n s = None\n except PrecisionExhausted:\n s = None\n\n if s is not None:\n return s*Pow(b, e*other)\n",
            "new_text": "def _eval_power(self, other):\n from sympy import Abs, arg, exp, floor, im, log, re, sign\n from sympy.core.function import _coeff_isneg\n b, e = self.as_base_exp()\n if b is S.NaN:\n return (b**e)**other # let __new__ handle it\n\n s = None\n if other.is_integer:\n s =1\n elif b.is_polar: # e.g. exp_polar, besselj, var('p', polar=True)...\n s =1\n elif e.is_real is not None:\n # helper functions ===========================\n def _half(e):\n \"\"\"Return True if the exponent has a literal2 as the\n denominator, else None.\"\"\"\n if getattr(e, 'q', None) ==2:\n return True\n n, d = e.as_numer_denom()\n if n.is_integer and d ==2:\n return True\n def _n2(e):\n \"\"\"Return ``e`` evaluated to a Number with2 significant\n digits, else None.\"\"\"\n try:\n rv = e.evalf(2, strict=True)\n if rv.is_Number:\n return rv\n except PrecisionExhausted:\n pass\n # ===================================================\n if e.is_real:\n # we need _half(other) with constant floor or\n # floor(S.Half - e*arg(b)/2/pi) ==0\n\n # handle -1 as special case\n if e == -1:\n # floor arg. is1/2 + arg(b)/2/pi\n if _half(other):\n if b.is_negative is True:\n return S.NegativeOne**other*Pow(-b, e*other)\n if b.is_real is False:\n return Pow(b.conjugate()/Abs(b)**2, other)\n elif e.is_even:\n if b.is_real:\n b = abs(b)\n if b.is_imaginary:\n b = abs(im(b))*S.ImaginaryUnit\n\n if (abs(e) <1) == True or e ==1:\n s =1 # floor =0\n elif b.is_nonnegative:\n s =1 # floor =0\n elif re(b).is_nonnegative and (abs(e) <2) == True:\n s =1 # floor =0\n elif fuzzy_not(im(b).is_zero) and abs(e) ==2:\n s =1 # floor =0\n elif _half(other):\n s = exp(2*S.Pi*S.ImaginaryUnit*other*floor(\n S.Half - e*arg(b)/(2*S.Pi)))\n if s.is_real and _n2(sign(s) - s) ==0:\n s = sign(s)\n else:\n s = None\n else:\n # e.is_real is False requires:\n # _half(other) with constant floor or\n # floor(S.Half - im(e*log(b))/2/pi) ==0\n try:\n s = exp(2*S.ImaginaryUnit*S.Pi*other*\n floor(S.Half - im(e*log(b))/2/S.Pi))\n # be careful to test that s is -1 or1 b/c sign(I) == I:\n # so check that s is real\n if s.is_real and _n2(sign(s) - s) ==0:\n s = sign(s)\n else:\n s = None\n except PrecisionExhausted:\n s = None\n\n if s is not None:\n if _coeff_isneg(b):\n if other.is_Rational and other.q ==2:\n if s.is_real:\n s = -s # maintain reality since (-1)**(1/2) = I\n return s*Pow(abs(b), e*other)\n return s*Pow(b, e*other)\n",
            "match_ratio": 0.6615096108766995,
            "match_segment": "def _eval_power(self, other):\n        from sympy import Abs, arg, exp, floor, im, log, re, sign\n        b, e = self.as_base_exp()\n        if b is S.NaN:\n            return (b**e)**other  # let __new__ handle it\n\n        s = None\n        if other.is_integer:\n            s = 1\n        elif b.is_polar:  # e.g. exp_polar, besselj, var('p', polar=True)...\n            s = 1\n        elif e.is_real is not None:\n            # helper functions ===========================\n            def _half(e):\n                \"\"\"Return True if the exponent has a literal 2 as the\n                denominator, else None.\"\"\"\n                if getattr(e, 'q', None) == 2:\n                    return True\n                n, d = e.as_numer_denom()\n                if n.is_integer and d == 2:\n                    return True\n            def _n2(e):\n                \"\"\"Return ``e`` evaluated to a Number with 2 significant\n                digits, else None.\"\"\"\n                try:\n                    rv = e.evalf(2, strict=True)\n                    if rv.is_Number:\n                        return rv\n                except PrecisionExhausted:\n                    pass\n            # ===================================================\n            if e.is_real:\n                # we need _half(other) with constant floor or\n                # floor(S.Half - e*arg(b)/2/pi) == 0\n\n                # handle -1 as special case\n                if e == -1:\n                    # floor arg. is 1/2 + arg(b)/2/pi\n                    if _half(other):\n                        if b.is_negative is True:\n                            return S.NegativeOne**other*Pow(-b, e*other)\n                        if b.is_real is False:\n                            return Pow(b.conjugate()/Abs(b)**2, other)\n                elif e.is_even:\n                    if b.is_real:\n                        b = abs(b)\n                    if b.is_imaginary:\n                        b = abs(im(b))*S.ImaginaryUnit\n\n                if (abs(e) < 1) == True or e == 1:\n                    s = 1  # floor = 0\n                elif b.is_nonnegative:\n                    s = 1  # floor = 0\n           ",
            "num_matches": 0
        }
    ]
}